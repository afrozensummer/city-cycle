<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no"/>
    <script type="text/javascript" src="http://maps.google.com/maps/api/js?sensor=true"></script>
    <script src="http://d3js.org/d3.v3.js" charset="utf-8"></script>
    <script src="libs/jquery.min.js" charset="utf-8"></script>
    <script src="js/slider.js"></script>
    <link href='https://api.tiles.mapbox.com/mapbox.js/v2.1.8/mapbox.css' rel='stylesheet' />
    <script src="http://cdn.leafletjs.com/leaflet-0.7/leaflet.js"></script>
    <script src='https://api.tiles.mapbox.com/mapbox.js/v2.1.8/mapbox.js'></script>
    <script src="http://d3js.org/queue.v1.min.js"></script>
    
    <link href='http://fonts.googleapis.com/css?family=Raleway' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="css/main.css">
    <style type="text/css">

html, body {
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
}

.bikes, .stations, .bikes svg, .stations svg {
  position: absolute;
}

.bikes, .stations svg {
  width: 60px;
  height: 20px;
  padding-right: 100px;
  font: 10px sans-serif;
}

.stations {
  fill: steelblue;
  opacity: 0.8;
/*  stroke: black;
  stroke-width: .8px;*/
}

.bikes {
  fill: #000;
  z-index: 1;
  opacity: 1;
} 

    </style>
  </head>
  <body class = "viscontainer"> 
    <div class = "header">
      CitiBike Visualization
    </div>
    <div>
      Lorem ipsum dolor sit amet, consectetur adipisicing elit. Voluptatem aspernatur facilis ipsum, beatae! Quasi amet ratione perspiciatis velit, excepturi nisi. Magni repellat amet illum ducimus cum. Saepe harum repellendus perspiciatis. <br><br>
    </div>
    <div id="time"> </div>
    <div id="slider"></div>
    <div id="map"></div> 
    <script type="text/javascript">

//Variables
var bike_data;
var station_data;
var starting_time = new Date("2014-12-01 0:10:30");
var current_time = starting_time;

queue()
  .defer(d3.json, "data/stations.json") 
  .defer(d3.csv, "data/december2014.csv")
    .await(function(error, stations, bikes) { 
        //error handling
        station_data = stations;
        bike_data = bikes;
        data_loaded();

  });

function data_loaded() {
  //console.log(bike_data);

  // Date Formating 
  var formatDate = d3.time.format("%a, %b %e, %H:%M");
  document.getElementById("time").innerHTML = "Current Time: " + formatDate(starting_time);

  // Create a date range slider
  var MyEventHandler = new Object();
  var slider = new Slider(d3.select("#slider"), [], MyEventHandler);

  // Handle the event for the slider
  $(MyEventHandler).bind("selectionChanged", function(event, value) {
    document.getElementById("time").innerHTML = "Current Time: " + formatDate(value.time);
    
    if(d3.time.minute.floor(new Date(value.time)) > d3.time.minute.floor(current_time)) {
      animate();
      current_time = new Date(value.time);
      console.log(current_time);
    }
  });

  // Build the map
  L.mapbox.accessToken = 'pk.eyJ1IjoiY2l0eWN5Y2xlIiwiYSI6IjZ3MXNtRW8ifQ.lmAxO5RTphn4Jo-QV63Vpg';
  var layer = L.mapbox.tileLayer('citycycle.lnkh0jpk');
  var map = L.map('map')
      .addLayer(layer)
      .setView([40.72332345541449, -73.99], 12);

  var svg = d3.select(map.getPanes().overlayPane).append("svg");
  //console.log(svg);
  var g = svg.append("g").attr("class", "leaflet-zoom-hide");

  var stationsList = station_data["stationBeanList"];
  
  // returns all the trips for that minute, use a while loop with a condition so we don't go needlessly into the data
  function data_for_minute(date) {
    var bike_list_minute = [];
    var i = 0;
    while (new Date(bike_data[i].starttime) < d3.time.minute.floor(d3.time.minute.offset(date,1))) {
      var bike_start_time = d3.time.minute.floor(new Date(bike_data[i].starttime));
      if(bike_start_time.getTime() === d3.time.minute.floor(date).getTime()) {
        var bikes_data = bike_data[i];
        
        // figure out range in minutes
        var range = d3.time.minute.floor(new Date(bike_data[i].stoptime)) - bike_start_time;
        range = range/(1000*60)
        var start_long = parseFloat(bikes_data["start station longitude"])
        var start_lat =parseFloat(bikes_data["start station latitude"])
        var end_long = parseFloat(bikes_data["end station longitude"])
        var end_lat = parseFloat(bikes_data["end station latitude"])

        var longitude_step = (end_long - start_long)/range;
        var latitude_step = (end_lat - start_lat)/range;

        //longitude_step = Math.round(longitude_step*10000000000)/10000000000;
        //latitude_step = Math.round(latitude_step*10000000000)/10000000000;

        console.log(latitude_step);
        console.log(longitude_step);

        bikes_data.time_line = d3.range(0,range+1).map(function(d,i) {
          return {time:new Date(bike_start_time.getTime() + i*(1000*60)), longitude:start_long + (i)*longitude_step, latitude:start_lat + (i)*latitude_step};
        })

        bikes_data.minute = 0;  
        bike_list_minute.push(bikes_data);
      }
      i++;
    }
    return bike_list_minute;
  }

  var minidata = data_for_minute(starting_time);
  console.log(minidata);

  var stations = g.selectAll("stations")
            .data(stationsList)
            .enter()
            .append("circle")
            .attr("r", 3)
            .attr("class", "stations");

  var bikes = g.selectAll("bikes")
          .data(minidata)
          .enter()
          .append("circle")
          .attr("r", 2)
          .attr("class", "bikes");

  function applyLatLngToLayer(d) {
    /*if (d.bikeid != null) {
      //console.log(d["start station latitude"]);
      var y = d["start station latitude"];
      var x = d["start station longitude"]
    }
    else {*/

      var y = d.latitude;
      var x = d.longitude;
      if (d.time != null) {
        console.log("x:" + x + " y:" + y);
        console.log(new L.LatLng(y, x).toString());
        //console.log(map.latLngToLayerPoint(new L.LatLng(y, x)));
      }     
    //} 
    return map.latLngToLayerPoint(new L.LatLng(y, x))
  }

  function reset() {

    var x_coors = [];
    var y_coors = [];

    stations.attr("transform",
                  function(d) {
                      var x = applyLatLngToLayer(d).x;
                      var y = applyLatLngToLayer(d).y;

                      x_coors.push(x);
                      y_coors.push(y);

                      return "translate(" +
                          x + "," +
                          y + ")";
                  });

    bikes
      .attr("transform",
                    function(d) {
                        new_coordinates = applyLatLngToLayer(d.time_line[d.minute]);
                        return "translate(" +
                             new_coordinates.x + "," +
                             new_coordinates.y + ")";
                    });

    var topLeft = [d3.min(x_coors), d3.min(y_coors)];
    var bottomRight = [d3.max(x_coors), d3.max(y_coors)];

    svg.attr("width", bottomRight[0] - topLeft[0] + 120)
                .attr("height", bottomRight[1] - topLeft[1] + 120)
                .style("left", topLeft[0] - 50 + "px")
                .style("top", topLeft[1] - 50 + "px");

    g.attr("transform", "translate(" + (-topLeft[0] + 50) + "," + (-topLeft[1] + 50) + ")");
  }

  function animate() {
   
    /*bikes.enter().call(function(d){ 
      console.log(d);
      if(d.minute == d.time_line.length) this.remove();
    });*/

    bikes
      .transition()
        .attr("transform",
                      function(d) {
                          // console.log(d.time_line[d.minute]);

                          if(d.minute == d.time_line.length) {
                            return "translate(" +
                               0 + "," +
                               0 + ")";
                          }

                          new_coordinates = applyLatLngToLayer(d.time_line[d.minute]);
                          console.log(new_coordinates);
                          d.minute++;
                          return "translate(" +
                               new_coordinates.x + "," +
                               new_coordinates.y + ")";
                      });
  }

  reset();
  map.on("viewreset", reset);
  
  /*for(var i = 0; i < 10; i ++) {
    setTimeout(function(){
      animate();
    //your code to be executed after 1 seconds
    },10000);
  }*/
 
}

    </script>

  </body>
</html>